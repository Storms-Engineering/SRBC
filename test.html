<html>
    <body>
        <meta charset="UTF-8">

        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/node-forge@0.7.0/dist/forge.min.js"></script>
        <script>
            function _arrayBufferToBase64( buffer ) {
    var binary = '';
    var bytes = new Uint8Array( buffer );
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode( bytes[ i ] );
    }
    return window.btoa( binary );
}
    function _base64ToArrayBuffer(base64) {
        var binary_string =  atob(base64);
        var len = binary_string.length;
        var bytes = new Array(len);
        for (var i = 0; i < len; i++)        {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    }
    function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 
                      0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                      | (str.charCodeAt(i) & 0x3ff));
            utf8.push(0xf0 | (charcode >>18), 
                      0x80 | ((charcode>>12) & 0x3f), 
                      0x80 | ((charcode>>6) & 0x3f), 
                      0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}
function byteArrayToChars(byteArray) {
        if (!byteArray) return "";
        let str = "";
        // String concatenation appears to be faster than an array join
        for (let i = 0; i < byteArray.length;) {
            str += String.fromCharCode(byteArray[i++]);
        }
        return str;
    }

            // generate a random key and IV
        // Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256
        var key =atob('rzIHsx6USwBGHaS4t2bnNg==');//forge.random.getBytesSync(16);
        console.log(atob('rzIHsx6USwBGHaS4t2bnNg=='))
        console.log(byteArrayToChars(atob('rzIHsx6USwBGHaS4t2bnNg==')));
        var utf8 = unescape(encodeURIComponent('+giCS+R0yjhzY4UEp6H1OosByg/cBxO9s0OjHLFn1HY='));

        var arr = [];
        for (var i = 0; i < utf8.length; i++) {
            arr.push(utf8.charCodeAt(i));
        }
        console.log(arr);
        var iv = atob('PG644GwVT8i+rpTVXEV9vw==');//forge.random.getBytesSync(16);

        /* alternatively, generate a password-based 16-byte key
        var salt = forge.random.getBytesSync(128);
        var key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);
        */

        // encrypt some bytes using CBC mode
        // (other modes include: ECB, CFB, OFB, CTR, and GCM)
        // Note: CBC and ECB modes use PKCS#7 padding as default
        var cipher = forge.cipher.createCipher('AES-CBC', key);
        cipher.start({iv: iv});
        cipher.update(forge.util.createBuffer("Yeet"));
        cipher.finish();
        var encrypted = cipher.output;
        console.log(encrypted);
        // outputs encrypted hex
        console.log(btoa(encrypted.getBytes()));
        console.log(toUTF8Array("Yeet"));

        
        
        </script>
    </body>
</html>